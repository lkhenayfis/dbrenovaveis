% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parseargs.r
\name{parsedatas}
\alias{parsedatas}
\title{Parse De Tipo Data(Hora)}
\usage{
parsedatas(datahoras, nome, query = TRUE, is_mock = TRUE)
}
\arguments{
\item{datahoras}{uma string indicando faixa de tempo no padrao do pacote \code{xts}}

\item{nome}{nome do campo para query}

\item{query}{booleano indicando se deve ser retornada a query ou apenas a expansao das datas}

\item{is_mock}{booleano indicando se o parse de argumentos esta sendo feito para query num banco
mock ou relacional}
}
\value{
se \code{query = TRUE} string contendo a condicao de busca associada a datas na query, do
contrario retorna apenas as datas expandidas
}
\description{
Transforma \code{datahoras} passado as funcoes \code{get*} numa string de query
}
\details{
Esta funcao e responsavel por traduzir as strings de janela temporal \code{datahora} em
condicionais de WHERE para a query.

Por padrao, todas as queries serao realizadas no padrao \code{data >= lim_1 AND data < lim_2},
isto e, serao sempre buscados intervalos fechados no inicio e abertos no final. Desta forma todos
os padroes de janela podem ser representados da mesma forma, simplificando a funcao.
}
\examples{

\dontrun{
cond <- parsedatas("2021", "data_hora")
identical(cond, "data_hora >= '2021-01-01 00:00:00' AND data_hora < '2022-01-01 00:00:00'")
}

\dontrun{
cond <- parsedatas("2020-11-30 12:30", "data_hora")
identical(cond, "data_hora >= '2020-11-30 12:30:00' AND data_hora < '2020-11-30 12:30:01'")
}

}
